"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericSequelizeDataService = void 0;
const IdHelper_1 = require("../../itf/generic/IdHelper");
const errorWithStatus_1 = require("../../../error/errorWithStatus");
const db_connections_1 = require("../../../db-connections/db-connections");
/*
De manière très exceptionnelle ,
sequelizeModel : any
ici car code générique se voulant compatible avec n'imporque quel model
(Devise , Customer, Product, ...)

==========
//console.log([Op.gte]); //display [ Symbol(gte) ]
//Sequelize peut (pour l'instant v4,v5,V6) interpréter $gte comme un équivalent à [Op.gte]
//si option operatorsAliases: {   $gte: Op.gte , ... } au niveau de new Sequelize()
//Ce qui est assez pratique pour avoir une syntaxe possible des query proche de celles de mongo/mongoose
}
*/
class GenericSequelizeDataService {
    constructor(connectionName, modelName, idHelper = new IdHelper_1.AutoIdHelper()) {
        this.connectionName = connectionName;
        this.modelName = modelName;
        this.idHelper = idHelper;
        this.sequelize = null;
        this.sequelizeModel = null;
    }
    // idHelper may be replaced/override in subclass:
    //by default id = alias for rowid (auto generated by sqlite)
    //may be overrided by static id (copy_or_renaming of .num or .code)
    //initModel() = utility function for accessing sequelize model and sequelize initialized in myAppConnectionMap
    //a idealement appeler dans constructeur d'une sous classe
    initModel() {
        return new Promise((resolve, reject) => {
            let mySequelizeConnection = db_connections_1.myAppConnectionMap.getConnection(this.connectionName);
            if (mySequelizeConnection.isInitialized()) {
                this.sequelize = mySequelizeConnection.currentDb();
                this.sequelizeModel = mySequelizeConnection.getModel(this.modelName);
                resolve(this.sequelizeModel);
            }
            else {
                mySequelizeConnection.openConnection()
                    .then((msg) => {
                    this.sequelize = mySequelizeConnection.currentDb();
                    this.sequelizeModel = mySequelizeConnection.getModel(this.modelName);
                    resolve(this.sequelizeModel);
                })
                    .catch((err) => reject(err));
            }
        });
    }
    buildQueryWithSingleKey(keyName, qValue) {
        let query = {};
        Reflect.defineProperty(query, keyName, { value: qValue, writable: true, enumerable: true, configurable: true });
        return query;
    }
    buildQueryById(id) {
        return this.buildQueryWithSingleKey(this.idHelper.getIdPropName(), id);
    }
    buildQueryByIdOfEntity(dataObj) {
        let idValue = this.idHelper.extractId(dataObj);
        return this.buildQueryWithSingleKey(this.idHelper.getIdPropName(), idValue);
    }
    findOne(query) {
        return new Promise((resolve, reject) => {
            let criteria = { where: query };
            this.sequelizeModel.findOne(criteria)
                .then((obj) => {
                //returning null by default if not Found
                if (obj != null)
                    resolve(obj);
                else
                    reject(new errorWithStatus_1.NotFoundError("entity not found "));
            })
                .catch((error) => { reject(error); });
        }); //end of Promise
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            this.sequelizeModel.findByPk(id)
                .then((obj) => {
                //returning null by default if not Found
                if (obj != null)
                    resolve(obj);
                else
                    reject(new errorWithStatus_1.NotFoundError("entity not found with pk=" + id));
            })
                .catch((error) => { reject(error); });
        }); //end of Promise
    }
    findList(query) {
        let criteria = { where: query };
        return new Promise((resolve, reject) => {
            console.log("criteria=" + JSON.stringify(criteria));
            this.sequelizeModel.findAll(criteria)
                .then((objects) => { resolve(objects); })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot find ")); });
        }); //end of Promise
    }
    findAll() {
        return new Promise((resolve, reject) => {
            this.sequelizeModel.findAll()
                .then((objects) => { resolve(objects); })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot findAll ")); });
        }); //end of Promise
    }
    basicSaveOrUpdate(dataObj) {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        if (this.idHelper.isAuto() && id == null) {
            return this.insert(dataObj);
        }
        else {
            return new Promise((resolve, reject) => {
                this.findById(id)
                    .then((existingEntityToUpdate) => {
                    //console.log("existing - need to be updated");
                    this.update(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                })
                    .catch((notFoundErr) => {
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                });
            });
        }
    }
    saveOrUpdate(e) {
        if (!this.idHelper.isAuto()) {
            return new Promise((resolve, reject) => {
                this.sequelizeModel.upsert(e)
                    .then((ok) => { resolve(e); })
                    .catch((error) => { reject(error); });
            }); //end of Promise
        }
        else
            return this.basicSaveOrUpdate(e);
    }
    insert(e) {
        return new Promise((resolve, reject) => {
            this.sequelizeModel.create(e)
                .then((obj) => { resolve(obj); })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot insert ")); });
        }); //end of Promise
    }
    update(e) {
        return new Promise((resolve, reject) => {
            let criteria = { where: this.buildQueryByIdOfEntity(e) };
            this.sequelizeModel.update(e, criteria)
                .then((nbUpdate) => {
                //console.log("nbUpdate="+nbUpdate)
                if (nbUpdate == 1)
                    resolve(e);
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot update ")); });
        }); //end of Promise
    }
    remove(query) {
        return new Promise((resolve, reject) => {
            let criteria = { where: query };
            this.sequelizeModel.destroy(criteria)
                .then((nbDelete) => {
                // console.log("nbDelete="+nbDelete)
                if (nbDelete == 1)
                    resolve();
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot remove ")); });
        }); //end of Promise
    }
    deleteById(id) {
        return this.remove(this.buildQueryById(id));
    }
}
exports.GenericSequelizeDataService = GenericSequelizeDataService;
