"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenericMongooseDataService = void 0;
const IdHelper_1 = require("../../itf/generic/IdHelper");
const errorWithStatus_1 = require("../../../error/errorWithStatus");
const db_connections_1 = require("../../../db-connections/db-connections");
class GenericMongooseDataService {
    //collectionName is modelName with as "s" suffix and in lowercase
    // idHelper may be replaced/override in subclass:
    //by default _id (auto generated by mongoDB)
    //may be overrided by static _id (copy_or_renaming of .num or .code)
    constructor(connectionName, modelName, idHelper = new IdHelper_1.Auto_IdHelper()) {
        this.connectionName = connectionName;
        this.modelName = modelName;
        this.idHelper = idHelper;
    }
    //initModel() = utility function for accessing mongoose model and mongoose connection initialized in myAppConnectionMap
    //a idealement appeler dans constructeur d'une sous classe
    initModel() {
        return new Promise((resolve, reject) => {
            let myMongooseConnection = db_connections_1.myAppConnectionMap.getConnection(this.connectionName);
            if (myMongooseConnection.isInitialized()) {
                this.mongooseConnection = myMongooseConnection.currentDb();
                this.mongooseModel = myMongooseConnection.getModel(this.modelName);
                resolve(this.mongooseModel);
            }
            else {
                myMongooseConnection.openConnection()
                    .then((msg) => {
                    this.mongooseConnection = myMongooseConnection.currentDb();
                    this.mongooseModel = myMongooseConnection.getModel(this.modelName);
                    resolve(this.mongooseModel);
                })
                    .catch((err) => reject(err));
            }
        });
    }
    buildQueryWithSingleKey(keyName, qValue) {
        let query = {};
        Reflect.defineProperty(query, keyName, { value: qValue, writable: true, enumerable: true, configurable: true });
        return query;
    }
    buildQueryByInternalId(id) {
        return this.buildQueryWithSingleKey(this.idHelper.getInternalIdPropName(), id);
    }
    buildQueryByInternalIdOfEntity(dataObj) {
        let idValue = this.idHelper.extractId(dataObj);
        idValue = idValue ? idValue : this.idHelper.extractInternalId(dataObj);
        return this.buildQueryWithSingleKey(this.idHelper.getInternalIdPropName(), idValue);
    }
    findOne(query) {
        return new Promise((resolve, reject) => {
            this.mongooseModel.findOne(query)
                .then((doc) => {
                //console.log("findOne , doc:"+doc ) 
                if (doc)
                    resolve(doc);
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot find ")); });
        }); //end of Promise
    }
    findById(id) {
        return new Promise((resolve, reject) => {
            this.mongooseModel.findById(id)
                .then((doc) => {
                //console.log("findById , doc:"+doc ) 
                if (doc)
                    resolve(doc);
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot find ")); });
        }); //end of Promise
    }
    findList(query) {
        //exemple de query : { prix : { $gte: 1.2 } }
        return new Promise((resolve, reject) => {
            this.mongooseModel.find(query)
                .then((docs) => { resolve(docs); })
                .catch((error) => { reject(new errorWithStatus_1.NotFoundError("not found")); });
        }); //end of Promise
    }
    findAll() {
        let query = {};
        return this.findList(query);
    }
    saveOrUpdate(dataObj) {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        if (this.idHelper.isAuto() && id == null) {
            return this.insert(dataObj);
        }
        else {
            return new Promise((resolve, reject) => {
                this.findById(id)
                    .then((existingEntityToUpdate) => {
                    //console.log("existing - need to be updated");
                    this.update(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                })
                    .catch((notFoundErr) => {
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res) => { resolve(res); })
                        .catch((err) => { reject(err); });
                });
            });
        }
    }
    insert(e) {
        return new Promise((resolve, reject) => {
            var persistentEntity = new this.mongooseModel(e);
            persistentEntity.save()
                .then((savedEntity) => {
                if (savedEntity)
                    resolve(savedEntity);
                else
                    reject(new errorWithStatus_1.ErrorWithStatus("cannot insert "));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot insert ")); });
        }); //end of Promise
    }
    update(e) {
        return new Promise((resolve, reject) => {
            const filter = this.buildQueryByInternalIdOfEntity(e);
            this.mongooseModel.updateOne(filter, e)
                .then((opResultObject) => {
                if (opResultObject.n != 0)
                    resolve(e);
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot update ")); });
        }); //end of Promise
    }
    remove(query) {
        return new Promise((resolve, reject) => {
            this.mongooseModel.deleteOne(query)
                .then((opResultObject) => {
                if (opResultObject.n != 0)
                    resolve();
                else
                    reject(new errorWithStatus_1.NotFoundError("not found"));
            })
                .catch((error) => { reject(new errorWithStatus_1.ErrorWithStatus("cannot remove ")); });
        }); //end of Promise
    }
    deleteById(id) {
        const filter = this.buildQueryByInternalId(id);
        return this.remove(filter);
    }
}
exports.GenericMongooseDataService = GenericMongooseDataService;
