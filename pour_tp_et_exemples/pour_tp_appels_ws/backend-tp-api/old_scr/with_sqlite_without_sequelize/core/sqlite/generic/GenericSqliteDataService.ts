import { BasicCrudService } from "../../itf/generic/BasicCrudService";
import { IdHelper, AutoIdHelper } from "../../itf/generic/IdHelper";
import { NotFoundError , ErrorWithStatus, ConflictError} from "../../../error/errorWithStatus";
import * as sqlite from 'sqlite3';
const sqlite3 = sqlite.verbose();
import { myAppConnectionMap } from "../../../db-connections/db-connections";
import { MySqliteConnection } from "../../../db-connections/GenericSqliteConnection"

export class GenericSqliteDataService<T,ID> implements BasicCrudService<T,ID>{

    
    // idHelper may be replaced/override in subclass:
              //by default id = alias for rowid (auto generated by sqlite)
              //may be overrided by static id (copy_or_renaming of .num or .code)

    constructor(protected connectionName : string,
                protected tableName : string , 
                protected idHelper : IdHelper<T,ID>  = new AutoIdHelper<T,ID>()){
    }

    //dbB() = utility function for accessing sqlite connection initialized in myAppConnectionMap
    protected dB() : Promise<sqlite.Database>{
        return new Promise((resolve,reject) => {
            let  mySqliteConnection : MySqliteConnection = myAppConnectionMap.getConnection(this.connectionName) as MySqliteConnection;
            if(mySqliteConnection.isInitialized())
                  resolve(mySqliteConnection.currentDb());
            else{
                mySqliteConnection.openConnection()
                       .then( (msg) => { resolve(mySqliteConnection.currentDb()); })
                       .catch( (err) => reject(err));
            }
        });
    }

    //NB: on doit pouvoir facilement basculer d'une base
    //sqlite avec souvent id ou _id ou rowid de type number
    //vers une base mongoDB avec souvent _id de type string
    //si model avec _id de type string , on ajutera une conversion en base:


    private adjustEntitiesId(entities:T[]){
            for(let e of entities){
                this.adjustEntityId(e)
            }
        return entities;
    }

    private adjustEntityId(e:T):T{
        if(this.idHelper.isAuto() &&  typeof this.idHelper.getDefaultInitialValue() == "string" ){
            let sId :any =  this.idHelper.extractId(e);
            sId = sId.toString();
            this.idHelper.setId(e,sId);
        }
        return e;
    }

    findOne(query: any): Promise<T> {
        //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve,reject) => {
            this.dB().then ( (db)=> {
                let sql = "SELECT * FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.get(sql, [] ,  (err, row) => {
                        if(err!=null) {
                            console.log("findOne error = " + err + " with query="+query);
                            reject(new ErrorWithStatus("findList exception / internal error"));
                        }else{ 
                            if(row)
                                resolve(this.adjustEntityId(row)); 
                            else 
                               reject(new NotFoundError("not found"));
                        }
                   }
                ); //end of db.all()
            });//end of this.dB().then()
        });//end of Promise
    }
    findById(id: ID): Promise<T> {
        return new Promise((resolve,reject) => {
            this.dB().then ( (db)=> {
                let sql = "SELECT * FROM " + this.tableName + " WHERE " + this.idHelper.getIdPropName() + "=?";
                //console.log("sql="+sql);
                db.get(sql, id ,  (err, row) => {
                        if(err!=null) {
                            console.log("findById error = " + err);
                            reject(new NotFoundError("not found "));
                        }else{ //NB: row may be null if not found
                            if(row)
                                resolve(this.adjustEntityId(row)); 
                            else 
                                reject(new NotFoundError("not found"));
                        }
                   }
                ); //end of db.get()
            });//end of this.dB().then()
        });//end of Promise
    }

    findList(query: any): Promise<T[]> {
        //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve,reject) => {
            this.dB().then ( (db)=> {
                let sql = "SELECT * FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.all(sql, [] ,  (err, rows) => {
                        if(err!=null) {
                            console.log("findList error = " + err + " with query="+query);
                            reject(new ErrorWithStatus("findList exception / internal error"));
                        }else{ 
                                resolve(this.adjustEntitiesId(rows)); 
                        }
                   }
                ); //end of db.all()
            });//end of this.dB().then()
        });//end of Promise
    }

    findAll(): Promise<T[]> {
        return this.findList("");
    }

    saveOrUpdate(dataObj: T): Promise<T> {
         //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
         let id : ID = this.idHelper.extractId(dataObj);
         //console.log("in saveOrUpdate() , id="+id);
         
         if(this.idHelper.isAuto() && id==null){
                 return this.insert(dataObj);
         }else{
             return new Promise((resolve,reject) => {
                  this.findById(id)
                  .then((existingEntityToUpdate)=>{
                      //console.log("existing - need to be updated");
                      this.update(dataObj).then((res)=>{resolve(res);})
                                          .catch((err)=>{reject(err)})
                   })
                  .catch((notFoundErr)=>{
                     //console.log("non existing - need to be inserted");
                     this.insert(dataObj).then((res)=>{resolve(res);})
                                         .catch((err)=>{reject(err)})
                  });
             });
         }
    }

   sqlInsertFromFieldList(e:T) : string { 
    let arrayOfPropKeys = Reflect.ownKeys(e as any as object); //may ignoring inheritance in old version
    let fieldNameList  = "(";
    let fieldParamList = "(";
    for(let propKey of arrayOfPropKeys){
        let propName  = <string> propKey;
        fieldNameList += (propName + ",")
        fieldParamList += "?,";
    }
    fieldNameList=fieldNameList.replace(/.$/,")")
    fieldParamList=fieldParamList.replace(/.$/,")")
    let sql =  "INSERT INTO " + this.tableName + fieldNameList + " VALUES" + fieldParamList;
    //console.log("sql=" + sql);
    return sql;
   }

   sqlUpdateFromFieldList(e:T) : string { 
    let idPropName = this.idHelper.getIdPropName();
    let arrayOfPropKeys = Reflect.ownKeys(e as any as object); //may ignoring inheritance in old version
    let fieldSetList  = "";
    for(let propKey of arrayOfPropKeys){
        let propName  = <string> propKey;
        if(propName != idPropName)
               fieldSetList += ( propName + "=? ,")
    }
    fieldSetList=fieldSetList.replace(/.$/," ")
    let sql =  "UPDATE " + this.tableName +" SET " + fieldSetList + " WHERE " + idPropName + "=?";
    //console.log("sql=" + sql);
    return sql;
   }

   sqlInsertFieldValues(e:T) : any[]{ 
    let fieldVals : any[] = [];
    let arrayOfPropKeys = Reflect.ownKeys(e as any as object);
    for(let propKey of arrayOfPropKeys){
        let propName  = <string> propKey;
        let fieldValue = Reflect.get(e as any as object ,propName);
        fieldVals.push(fieldValue);
    }
    return fieldVals ; 
  }

  sqlUpdateFieldValues(e:T) : any[]{ 
    let idPropName = this.idHelper.getIdPropName();
    let fieldVals : any[] = [];
    let arrayOfPropKeys = Reflect.ownKeys(e as any as object);
    for(let propKey of arrayOfPropKeys){
        let propName  = <string> propKey;
        if(propName != idPropName) {
            let fieldValue = Reflect.get(e as any as object ,propName);
            fieldVals.push(fieldValue);
        }
    }
    let idFieldValue = Reflect.get(e as any as object ,idPropName);
    fieldVals.push(idFieldValue);//en remplacement du dernier ?
    return fieldVals ; 
  }

    insert(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            let idHelper : IdHelper<T,ID>  = this.idHelper;
            let idPropName = this.idHelper.getIdPropName();
            this.dB().then ( (db)=> {
                var pst = db.prepare( this.sqlInsertFromFieldList(e));
                pst.run( this.sqlInsertFieldValues(e), function (err) {
                        //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                        if(err!=null) {
                            console.log("generic insert error = " + err);
                            reject(new ErrorWithStatus("sql insert exception / internal error"));
                           
                        }else{ 
                            if(this.changes==0)
                                reject(new NotFoundError("not inserted "));
                            else{
                                if(idHelper.isAuto){
                                    let lastID :any =this.lastID; //as number
                                    if(typeof idHelper.getDefaultInitialValue() == "string"){
                                        lastID = lastID.toString();
                                    }
                                    Reflect.set(e as any as object,idPropName ,lastID);
                                }
                                    resolve(e); 
                            }
                        }
                   }
                ); //end of db.run()
                pst.finalize();
            });//end of this.dB().then()
        });//end of Promise
    }
    update(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            let idPropName = this.idHelper.getIdPropName();
            this.dB().then ( (db)=> {
                var pst = db.prepare( this.sqlUpdateFromFieldList(e));
                pst.run( this.sqlUpdateFieldValues(e), function (err) {
                       //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                       if(err!=null) {
                            console.log("generic update error = " + err);
                            reject(new ErrorWithStatus("sql update exception / internal error"));
                           
                        }else{ 
                            if(this.changes==0)
                                reject(new NotFoundError("not updated "));
                            else{
                                resolve(e); 
                            }
                        }
                   }
                ); //end of db.run()
                pst.finalize();
            });//end of this.dB().then()
        });//end of Promise
    }
    remove(query: any): Promise<void> {
         //NB: V1 (simple) query considérée comme clause vide ou "WHERE fielName=Value" sans "?"
        return new Promise((resolve,reject) => {
            this.dB().then ( (db)=> {
                let sql = "DELETE FROM " + this.tableName + query;
                //console.log("sql="+sql);
                db.run(sql, [] ,  function (err) {
                        //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                        if(err!=null) {
                            console.log("generic remove error = " + err);
                            reject(new ErrorWithStatus("sql delete exception / internal error"));
                           
                        }else{ 
                            if(this.changes==0)
                                reject(new NotFoundError("not found "));
                            else
                                resolve(); 
                        }
                   }
                ); //end of db.run()
            });//end of this.dB().then()
        });//end of Promise
    }
    deleteById(id: ID): Promise<void> {
        return new Promise((resolve,reject) => {
            this.dB().then ( (db)=> {
                let sql = "DELETE FROM " + this.tableName + " WHERE " + this.idHelper.getIdPropName() + "=?";
                //console.log("sql="+sql);
                db.run(sql, id ,  function (err) {
                        //NB: not lambda/arrow function here , beaucause need of retreiving this.changes or this.lastID
                        if(err!=null) {
                            console.log("genericDeleteById error = " + err);
                            reject(new ErrorWithStatus("sql delete exception / internal error"));
                           
                        }else{ 
                            if(this.changes==0)
                                reject(new NotFoundError("not found "));
                            else
                                resolve(); 
                        }
                   }
                ); //end of db.run()
            });//end of this.dB().then()
        });//end of Promise
    }

}