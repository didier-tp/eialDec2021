import { BasicCrudService } from "../../itf/generic/BasicCrudService";
import { IdHelper, Auto_IdHelper } from "../../itf/generic/IdHelper";
import { NotFoundError , ErrorWithStatus, ConflictError} from "../../../error/errorWithStatus";

import mongoose from 'mongoose';
import { MyMongooseConnection } from "../../../db-connections/GenericMongooseConnection";
import { myAppConnectionMap } from "../../../db-connections/db-connections"

type AnyMongooseModel = mongoose.Model<mongoose.Document<any, {}>, {}>


type PersistentModel<T> = mongoose.Model<mongoose.Document<T>,{}>


export class GenericMongooseDataService<T,ID> implements BasicCrudService<T,ID>{

    protected mongooseConnection : mongoose.Connection ; 
    protected mongooseModel : PersistentModel<T> ; 

    //collectionName is modelName with as "s" suffix and in lowercase
    

    // idHelper may be replaced/override in subclass:
              //by default _id (auto generated by mongoDB)
              //may be overrided by static _id (copy_or_renaming of .num or .code)

    constructor(protected connectionName : string,
                protected modelName : string , 
                protected idHelper : IdHelper<T,ID>  = new Auto_IdHelper<T,ID>()){
    
    }

    //initModel() = utility function for accessing mongoose model and mongoose connection initialized in myAppConnectionMap
    //a idealement appeler dans constructeur d'une sous classe
    protected initModel() : Promise<AnyMongooseModel>{
        return new Promise((resolve,reject) => {
            let  myMongooseConnection : MyMongooseConnection = myAppConnectionMap.getConnection(this.connectionName) as MyMongooseConnection;
            if(myMongooseConnection.isInitialized()){
                  this.mongooseConnection=myMongooseConnection.currentDb();
                  this.mongooseModel=myMongooseConnection.getModel(this.modelName);
                  resolve(this.mongooseModel);
            }
            else{
                myMongooseConnection.openConnection()
                       .then( (msg) => { 
                        this.mongooseConnection=myMongooseConnection.currentDb();
                        this.mongooseModel=myMongooseConnection.getModel(this.modelName);
                         resolve(this.mongooseModel);
                         })
                       .catch( (err) => reject(err));
            }
        });
    }

    private buildQueryWithSingleKey(keyName :string, qValue:any) : object{
        let query = {};
        Reflect.defineProperty(query, keyName, {value: qValue ,writable : true, enumerable : true, configurable : true});
        return query;
    }

    private buildQueryByInternalId(id: ID) : object{
        return this.buildQueryWithSingleKey( this.idHelper.getInternalIdPropName() , id);
    }


    private buildQueryByInternalIdOfEntity(dataObj: T) : object{
        let idValue : ID = this.idHelper.extractId(dataObj)
        idValue=idValue?idValue:this.idHelper.extractInternalId(dataObj)
        return this.buildQueryWithSingleKey( this.idHelper.getInternalIdPropName() ,idValue );
    }

    findOne(query: any): Promise<T> {
        return new Promise((resolve,reject) => {
            this.mongooseModel.findOne(query)
                    .then((doc: mongoose.Document<T>) => { 
                        //console.log("findOne , doc:"+doc ) 
                        if(doc)
                           resolve(doc as any); 
                        else reject(new NotFoundError("not found"));
                    })
                    .catch((error: Error) => { reject(new ErrorWithStatus("cannot find ")); });
         });//end of Promise
    }

    findById(id: ID): Promise<T> {
        return new Promise((resolve,reject) => {
            this.mongooseModel.findById(id)
                    .then((doc: mongoose.Document<T>) => { 
                        //console.log("findById , doc:"+doc ) 
                        if(doc)
                           resolve(doc as any); 
                        else reject(new NotFoundError("not found"));
                    })
                    .catch((error: Error) => { reject(new ErrorWithStatus("cannot find ")); });
         });//end of Promise
    }

    findList(query: any): Promise<T[]> {
        //exemple de query : { prix : { $gte: 1.2 } }
        return new Promise((resolve,reject) => {
            this.mongooseModel.find(query)
                    .then((docs: mongoose.Document<T>[]) => {  resolve(docs as any); })
                    .catch((error: Error) => { reject(new NotFoundError("not found")); });
         });//end of Promise
    }

    findAll(): Promise<T[]> {
       let query = {};
       return this.findList(query);
    }
    
    saveOrUpdate(dataObj: T): Promise<T> {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id : ID = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        
        if(this.idHelper.isAuto() && id==null){
                return this.insert(dataObj);
        }else{
            return new Promise((resolve,reject) => {
                 this.findById(id)
                 .then((existingEntityToUpdate)=>{
                     //console.log("existing - need to be updated");
                     this.update(dataObj).then((res)=>{resolve(res);})
                                         .catch((err)=>{reject(err)})
                  })
                 .catch((notFoundErr)=>{
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res)=>{resolve(res);})
                                        .catch((err)=>{reject(err)})
                 });
            });
        }
    }

    insert(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            var persistentEntity = new this.mongooseModel(e);
            persistentEntity.save()
                     .then((savedEntity) => {  
                         if(savedEntity)
                             resolve(savedEntity as any as T);
                         else  
                             reject(new ErrorWithStatus("cannot insert "));
                      })
                     .catch((error: Error) => { reject(new ErrorWithStatus("cannot insert ")); });
          });//end of Promise
    }

    update(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            const filter = this.buildQueryByInternalIdOfEntity(e);
            this.mongooseModel.updateOne(filter,e)
                     .then((opResultObject) => {  
                         if(opResultObject.n !=0 )
                             resolve(e);
                         else  
                             reject(new NotFoundError("not found"));
                      })
                     .catch((error: Error) => { reject(new ErrorWithStatus("cannot update ")); });
          });//end of Promise
    }

    remove(query: any): Promise<void> {
        return new Promise((resolve,reject) => {
           this.mongooseModel.deleteOne(query)
                    .then((opResultObject) => {  
                        if(opResultObject.n !=0 )
                            resolve();
                        else  
                            reject(new NotFoundError("not found"));
                     })
                    .catch((error: Error) => { reject(new ErrorWithStatus("cannot remove ")); });
         });//end of Promise
    }

    deleteById(id: ID): Promise<void> {
        const filter = this.buildQueryByInternalId(id);
        return this.remove(filter);
    }

    
    



}