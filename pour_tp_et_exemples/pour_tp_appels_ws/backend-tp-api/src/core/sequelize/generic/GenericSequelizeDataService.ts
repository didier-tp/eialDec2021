import { BasicCrudService } from "../../itf/generic/BasicCrudService";
import { IdHelper, AutoIdHelper } from "../../itf/generic/IdHelper";
import { NotFoundError , ErrorWithStatus, ConflictError} from "../../../error/errorWithStatus";
import { myAppConnectionMap } from "../../../db-connections/db-connections";
import { MySequelizeConnection } from "../../../db-connections/GenericSequelizeConnection"
import { Sequelize , Model , Op, BuildOptions}from "sequelize";


/*
De manière très exceptionnelle ,
sequelizeModel : any 
ici car code générique se voulant compatible avec n'imporque quel model
(Devise , Customer, Product, ...)

==========
//console.log([Op.gte]); //display [ Symbol(gte) ]
//Sequelize peut (pour l'instant v4,v5,V6) interpréter $gte comme un équivalent à [Op.gte] 
//si option operatorsAliases: {   $gte: Op.gte , ... } au niveau de new Sequelize()
//Ce qui est assez pratique pour avoir une syntaxe possible des query proche de celles de mongo/mongoose
}
*/

export class GenericSequelizeDataService<T,ID> implements BasicCrudService<T,ID>{

    protected sequelize : Sequelize =null;
    protected sequelizeModel : any = null;

    
    // idHelper may be replaced/override in subclass:
              //by default id = alias for rowid (auto generated by sqlite)
              //may be overrided by static id (copy_or_renaming of .num or .code)


    //initModel() = utility function for accessing sequelize model and sequelize initialized in myAppConnectionMap
    //a idealement appeler dans constructeur d'une sous classe
    protected initModel() : Promise<Model>{
        return new Promise((resolve,reject) => {
            let  mySequelizeConnection : MySequelizeConnection = myAppConnectionMap.getConnection(this.connectionName) as MySequelizeConnection;
            if(mySequelizeConnection.isInitialized()){
                  this.sequelize=mySequelizeConnection.currentDb();
                  this.sequelizeModel=mySequelizeConnection.getModel(this.modelName);
                  resolve(this.sequelizeModel);
            }
            else{
                mySequelizeConnection.openConnection()
                       .then( (msg) => { 
                        this.sequelize=mySequelizeConnection.currentDb();
                        this.sequelizeModel=mySequelizeConnection.getModel(this.modelName);
                        resolve(this.sequelizeModel);
                         })
                       .catch( (err) => reject(err));
            }
        });
    }

    constructor(protected connectionName : string,
                protected modelName : string , 
                protected idHelper : IdHelper<T,ID>  = new AutoIdHelper<T,ID>()){
                   
    }

    private buildQueryWithSingleKey(keyName :string, qValue:any) : object{
        let query = {};
        Reflect.defineProperty(query, keyName, {value: qValue ,writable : true, enumerable : true, configurable : true});
        return query;
    }

    private buildQueryById(id: ID) : object{
        return this.buildQueryWithSingleKey( this.idHelper.getIdPropName() , id);
    }


    private buildQueryByIdOfEntity(dataObj: T) : object{
        let idValue : ID = this.idHelper.extractId(dataObj)
        return this.buildQueryWithSingleKey( this.idHelper.getIdPropName() ,idValue );
    }

    findOne(query: any): Promise<T> {
        return new Promise((resolve,reject) => {
            let criteria = { where : query}
            this.sequelizeModel.findOne(criteria)
                .then((obj: T) => {
                    //returning null by default if not Found
                    if(obj!=null)
                       resolve(obj);
                    else
                       reject(new NotFoundError("entity not found "));
                    })
                .catch((error: any) => { reject(error); });
         });//end of Promise
    }

    findById(id: ID): Promise<T> {
        return new Promise((resolve,reject) => {
            this.sequelizeModel.findByPk(id)
                .then((obj: T) => {
                    //returning null by default if not Found
                    if(obj!=null)
                       resolve(obj);
                    else
                       reject(new NotFoundError("entity not found with pk="+id));
                    })
                .catch((error: any) => { reject(error); });
         });//end of Promise
    }

    findList(query: any): Promise<T[]> {
        
        
        let criteria = { where : query }
        return new Promise((resolve,reject) => {
            console.log("criteria="+JSON.stringify(criteria));
            this.sequelizeModel.findAll(criteria)
                .then((objects: T[]) => { resolve(objects); })
                .catch((error: Error) => { reject(new ErrorWithStatus("cannot find ")) });
     });//end of Promise
    }

    findAll(): Promise<T[]> {
     return new Promise((resolve,reject) => {
            this.sequelizeModel.findAll()
                .then((objects: T[]) => { resolve(objects); })
                .catch((error: Error) => { reject(new ErrorWithStatus("cannot findAll ")); });
     });//end of Promise
    }

    private basicSaveOrUpdate(dataObj: T): Promise<T> {
        //console.log("in saveOrUpdate() , dataObj="+JSON.stringify(dataObj));
        let id : ID = this.idHelper.extractId(dataObj);
        //console.log("in saveOrUpdate() , id="+id);
        
        if(this.idHelper.isAuto() && id==null){
                return this.insert(dataObj);
        }else{
            return new Promise((resolve,reject) => {
                 this.findById(id)
                 .then((existingEntityToUpdate)=>{
                     //console.log("existing - need to be updated");
                     this.update(dataObj).then((res)=>{resolve(res);})
                                         .catch((err)=>{reject(err)})
                  })
                 .catch((notFoundErr)=>{
                    //console.log("non existing - need to be inserted");
                    this.insert(dataObj).then((res)=>{resolve(res);})
                                        .catch((err)=>{reject(err)})
                 });
            });
        }
    }

    saveOrUpdate(e: T): Promise<T> {
        if(!this.idHelper.isAuto()){
            return new Promise((resolve,reject) => {
                        this.sequelizeModel.upsert(e) 
                            .then((ok: Boolean) => { resolve(e); })
                            .catch((error: any) => { reject(error); });
            });//end of Promise
        }else
          return this.basicSaveOrUpdate(e);
    }

    insert(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            this.sequelizeModel.create(e) 
                .then((obj: T) => { resolve(obj); })
                .catch((error: any) => { reject(new ErrorWithStatus("cannot insert ")); });
         });//end of Promise
    }

    update(e: T): Promise<T> {
        return new Promise((resolve,reject) => {
            let criteria = { where: this.buildQueryByIdOfEntity(e) }
            this.sequelizeModel.update(e,criteria) 
                .then((nbUpdate: number) => { 
                    //console.log("nbUpdate="+nbUpdate)
                    if(nbUpdate==1)
                         resolve(e); 
                     else reject(new NotFoundError("not found"));
                })
                .catch((error: any) => { reject(new ErrorWithStatus("cannot update ")); });
         });//end of Promise
    }

    remove(query: any): Promise<void> {
        return new Promise((resolve,reject) => {
            let criteria = { where: query } 
            this.sequelizeModel.destroy( criteria )
                .then((nbDelete: number) => { 
                   // console.log("nbDelete="+nbDelete)
                    if(nbDelete==1)
                       resolve(); 
                    else reject(new NotFoundError("not found"));
                })
                .catch((error: any) => { reject(new ErrorWithStatus("cannot remove ")); });
         });//end of Promise
    }
    deleteById(id: ID): Promise<void> {
        return this.remove(this.buildQueryById(id));
    }

    
}